ğŸ” Problem Statement
Given an array height[] where each index represents the height of a bar, compute how much rainwater can be trapped between the bars.

Example input:

int[] height = {3, 0, 1, 0, 4, 0, 2};
ğŸ“Š Visually, it looks like this:


Index:  0 1 2 3 4 5 6
Height: 3 0 1 0 4 0 2
Water gets trapped in dips between taller bars.

âœ… Output
For the input {3, 0, 1, 0, 4, 0, 2},
the function will return 10 â€” meaning 10 units of water trapped.

ğŸ§  Core Idea (Two Pointer Approach)
We move two pointers (left and right) from both ends inward, tracking:

leftMax: highest bar seen so far from the left

rightMax: highest bar seen so far from the right

ğŸš¨ At each step:
Water trapped at a position = min(leftMax, rightMax) - height[i]

But we only compute it where it's safe, by always processing the shorter side first.

ğŸ” Code Explanation
public static int trap(int[] height) {
    if (height == null || height.length == 0) return 0;

    int left = 0, right = height.length - 1;
    int leftMax = 0, rightMax = 0;
    int waterTrapped = 0;
â¤ Initialization:
left, right: pointers at both ends

leftMax, rightMax: track highest seen so far

waterTrapped: accumulates the result


    while (left <= right) {
Loop until pointers meet.

ğŸ§­ Inside the loop:

        if (height[left] <= height[right]) {
We always process the smaller side, because the trapped water depends on the shorter boundary.

ğŸ”¹ Left side case:

            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                waterTrapped += leftMax - height[left];
            }
            left++;
If current height â‰¥ leftMax â†’ update leftMax

Else â†’ water is trapped above it = leftMax - height[left]

Move left pointer to the right

ğŸ”¸ Right side case:

        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                waterTrapped += rightMax - height[right];
            }
            right--;
        }
Same logic for the right side.

ğŸ”š Finally:

    return waterTrapped;
}
Returns total water trapped.

âœ… Dry Run Example
Input: {3, 0, 1, 0, 4, 0, 2}

Water trapped at each index:

index 1 â†’ 3 - 0 = 3

index 2 â†’ 3 - 1 = 2

index 3 â†’ 3 - 0 = 3

index 5 â†’ 4 - 0 = 4

index 6 â†’ not enough height on right side

ğŸ§® Total = 3 + 2 + 3 + 2 = 10

âœ… Time & Space Complexity

Metric	Value
Time	O(n) â€“ one pass
Space	O(1) â€“ constant space (no extra arrays)
Efficiency	High
ğŸ“Œ Summary

Point	Description
âœ… Approach	Two-pointer, space-optimized
ğŸ¯ Handles	All dips and traps
ğŸ’¡ Core logic	Water is trapped where current height is less than min(leftMax, rightMax)
ğŸ‘Œ Best For	Interview-ready solution, production-grade performance